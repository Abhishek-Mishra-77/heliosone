import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import { format } from 'date-fns'

interface ReportOptions {
  title: string
  organization: string
  date: Date
  type: 'resiliency' | 'gap' | 'maturity' | 'department'
  data: any
}

export function generateReport(options: ReportOptions) {
  const doc = new jsPDF()
  const pageWidth = doc.internal.pageSize.width
  const pageHeight = doc.internal.pageSize.height
  const margin = 20

  // Header
  doc.setFontSize(20)
  doc.text(options.title, pageWidth / 2, margin, { align: 'center' })
  
  doc.setFontSize(12)
  doc.text(`Organization: ${options.organization}`, margin, margin + 10)
  doc.text(`Date: ${format(options.date, 'MMMM d, yyyy')}`, margin, margin + 20)
  doc.text(`Type: ${options.type.charAt(0).toUpperCase() + options.type.slice(1)} Assessment`, margin, margin + 30)

  // Add standard reference
  doc.setFontSize(10)
  doc.text('Industry Standards Reference:', margin, margin + 45)
  const standards = {
    resiliency: ['ISO 22301:2019', 'NIST SP 800-34', 'BCI Good Practice Guidelines'],
    gap: ['ISO 22301:2019', 'NIST SP 800-34', 'FFIEC BCM'],
    maturity: ['ISO 22301:2019', 'CMMI', 'COBIT'],
    department: ['ISO 22301:2019', 'NIST SP 800-34']
  }
  standards[options.type].forEach((standard, index) => {
    doc.text(`â€¢ ${standard}`, margin + 10, margin + 55 + (index * 7))
  })

  let yPos = margin + 80

  switch (options.type) {
    case 'resiliency':
      generateResiliencyReport(doc, options.data, yPos)
      break
    case 'gap':
      generateGapReport(doc, options.data, yPos)
      break
    case 'maturity':
      generateMaturityReport(doc, options.data, yPos)
      break
    case 'department':
      generateDepartmentReport(doc, options.data, yPos)
      break
  }

  // Footer
  const pageCount = doc.internal.getNumberOfPages()
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i)
    doc.setFontSize(8)
    doc.text(
      `Generated by Helios BCDR Platform - Page ${i} of ${pageCount}`,
      pageWidth / 2,
      pageHeight - 10,
      { align: 'center' }
    )
  }

  return doc
}

function generateResiliencyReport(doc: jsPDF, data: any, startY: number) {
  // Overall Score
  doc.setFontSize(14)
  doc.text('Overall Resiliency Score', 20, startY)
  
  doc.setFontSize(12)
  autoTable(doc, {
    startY: startY + 10,
    head: [['Category', 'Score', 'Trend', 'Status']],
    body: Object.entries(data.categoryScores).map(([category, score]: [string, any]) => [
      category,
      `${score.score}%`,
      `${score.trend > 0 ? '+' : ''}${score.trend}%`,
      score.score >= 80 ? 'Strong' : score.score >= 60 ? 'Moderate' : 'Needs Improvement'
    ])
  })

  // Response Metrics
  const metrics = data.responseMetrics
  doc.setFontSize(14)
  doc.text('Response Metrics', 20, doc.lastAutoTable.finalY + 20)

  autoTable(doc, {
    startY: doc.lastAutoTable.finalY + 30,
    head: [['Metric', 'Current', 'Target', 'Trend']],
    body: [
      ['Mean Time to Detect', `${metrics.meanTimeToDetect}m`, '< 30m', `${metrics.trendMTTD}%`],
      ['Mean Time to Respond', `${metrics.meanTimeToRespond}m`, '< 60m', `${metrics.trendMTTR}%`],
      ['Mean Time to Recover', `${metrics.meanTimeToRecover}h`, '< 4h', `${metrics.trendMTTR2}%`]
    ]
  })

  // Critical Findings
  doc.setFontSize(14)
  doc.text('Critical Findings & Recommendations', 20, doc.lastAutoTable.finalY + 20)

  const findings = Object.entries(data.categoryScores)
    .filter(([_, score]: [string, any]) => score.score < 60 || score.criticalFindings > 0)
    .map(([category, score]: [string, any]) => [
      category,
      score.criticalFindings,
      score.score < 60 ? 'Immediate attention required' : 'Action needed',
      score.evidenceCompliance < 80 ? 'Evidence gaps identified' : 'Evidence requirements met'
    ])

  if (findings.length > 0) {
    autoTable(doc, {
      startY: doc.lastAutoTable.finalY + 30,
      head: [['Category', 'Critical Findings', 'Status', 'Evidence Status']],
      body: findings
    })
  }
}

function generateGapReport(doc: jsPDF, data: any, startY: number) {
  // Overall Gap Analysis
  doc.setFontSize(14)
  doc.text('Gap Analysis Summary', 20, startY)

  autoTable(doc, {
    startY: startY + 10,
    head: [['Category', 'Current State', 'Target State', 'Gap Level']],
    body: Object.entries(data.categoryScores).map(([category, score]: [string, any]) => [
      category,
      `${score.score}%`,
      '100%',
      score.score >= 80 ? 'Minor' : score.score >= 60 ? 'Moderate' : 'Significant'
    ])
  })

  // Gap Distribution
  doc.setFontSize(14)
  doc.text('Gap Distribution', 20, doc.lastAutoTable.finalY + 20)

  autoTable(doc, {
    startY: doc.lastAutoTable.finalY + 30,
    head: [['Severity', 'Count', 'Impact Level', 'Priority']],
    body: [
      ['Critical', data.criticalGaps, 'Severe', 'Immediate'],
      ['High', data.highGaps, 'Significant', 'High'],
      ['Medium', data.mediumGaps, 'Moderate', 'Medium'],
      ['Low', data.lowGaps, 'Minor', 'Low']
    ]
  })

  // Compliance Status
  doc.setFontSize(14)
  doc.text('Compliance Status', 20, doc.lastAutoTable.finalY + 20)

  autoTable(doc, {
    startY: doc.lastAutoTable.finalY + 30,
    head: [['Requirement', 'Status', 'Gap Level', 'Action Needed']],
    body: Object.entries(data.complianceStatus || {}).map(([req, status]: [string, any]) => [
      req,
      status.compliant ? 'Compliant' : 'Non-Compliant',
      status.gapLevel,
      status.action
    ])
  })
}

function generateMaturityReport(doc: jsPDF, data: any, startY: number) {
  // Overall Maturity
  doc.setFontSize(14)
  doc.text('Maturity Assessment Summary', 20, startY)

  autoTable(doc, {
    startY: startY + 10,
    head: [['Category', 'Maturity Level', 'Score', 'Evidence Compliance']],
    body: Object.entries(data.categoryScores).map(([category, score]: [string, any]) => [
      category,
      score.level,
      `${score.score}%`,
      `${score.evidenceCompliance}%`
    ])
  })

  // Maturity Level Distribution
  doc.setFontSize(14)
  doc.text('Maturity Level Distribution', 20, doc.lastAutoTable.finalY + 20)

  autoTable(doc, {
    startY: doc.lastAutoTable.finalY + 30,
    head: [['Level', 'Description', 'Categories', 'Status']],
    body: [
      ['Level 5', 'Optimizing', data.levelDistribution.level5, 'Continuous Improvement'],
      ['Level 4', 'Managed', data.levelDistribution.level4, 'Quantitatively Managed'],
      ['Level 3', 'Defined', data.levelDistribution.level3, 'Organization Defined'],
      ['Level 2', 'Repeatable', data.levelDistribution.level2, 'Project Managed'],
      ['Level 1', 'Initial', data.levelDistribution.level1, 'Ad hoc']
    ]
  })

  // Improvement Recommendations
  doc.setFontSize(14)
  doc.text('Maturity Improvement Recommendations', 20, doc.lastAutoTable.finalY + 20)

  const recommendations = Object.entries(data.categoryScores)
    .filter(([_, score]: [string, any]) => score.level < 3)
    .map(([category, score]: [string, any]) => [
      category,
      score.level,
      3,
      `Improve ${category.toLowerCase()} capabilities to reach at least level 3`
    ])

  if (recommendations.length > 0) {
    autoTable(doc, {
      startY: doc.lastAutoTable.finalY + 30,
      head: [['Category', 'Current Level', 'Target Level', 'Recommendation']],
      body: recommendations
    })
  }
}

function generateDepartmentReport(doc: jsPDF, data: any, startY: number) {
  // Department Overview
  doc.setFontSize(14)
  doc.text('Department Assessment Summary', 20, startY)

  autoTable(doc, {
    startY: startY + 10,
    head: [['Department', 'Score', 'Status', 'Critical Findings']],
    body: Object.entries(data.departmentScores).map(([dept, score]: [string, any]) => [
      dept,
      `${score.score}%`,
      score.status.replace('_', ' ').toUpperCase(),
      score.criticalFindings
    ])
  })

  // Completion Status
  doc.setFontSize(14)
  doc.text('Assessment Completion Status', 20, doc.lastAutoTable.finalY + 20)

  autoTable(doc, {
    startY: doc.lastAutoTable.finalY + 30,
    head: [['Metric', 'Value', 'Target', 'Status']],
    body: [
      ['Total Departments', data.totalDepartments, data.totalDepartments, 'N/A'],
      ['Assessed Departments', data.assessedDepartments, data.totalDepartments, `${Math.round((data.assessedDepartments / data.totalDepartments) * 100)}%`],
      ['Overall Score', `${data.overallScore}%`, '80%', data.overallScore >= 80 ? 'Met' : 'Not Met'],
      ['Critical Findings', Object.values(data.departmentScores).reduce((acc: number, dept: any) => acc + dept.criticalFindings, 0), '0', 'Action Required']
    ]
  })

  // Department Recommendations
  doc.setFontSize(14)
  doc.text('Department-Specific Recommendations', 20, doc.lastAutoTable.finalY + 20)

  const recommendations = Object.entries(data.departmentScores)
    .filter(([_, score]: [string, any]) => score.score < 60 || score.criticalFindings > 0)
    .map(([dept, score]: [string, any]) => [
      dept,
      score.criticalFindings > 0 ? 'Critical' : 'High',
      `${score.score}%`,
      score.criticalFindings > 0 
        ? `Address ${score.criticalFindings} critical findings`
        : 'Improve overall resilience score'
    ])

  if (recommendations.length > 0) {
    autoTable(doc, {
      startY: doc.lastAutoTable.finalY + 30,
      head: [['Department', 'Priority', 'Current Score', 'Recommendation']],
      body: recommendations
    })
  }
}